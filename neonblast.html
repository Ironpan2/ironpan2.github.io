<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blast 3D - Precision Update</title>
    <style>
        /* --- CORE STYLES --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        /* --- UI OVERLAY --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        .hud-text { position: absolute; font-weight: 900; letter-spacing: 1px; text-shadow: 2px 2px 0px rgba(0,0,0,1); font-style: italic; }
        
        /* TOP LEFT */
        #score-container { top: 30px; left: 40px; color: #fff; font-size: 32px; }
        #score { color: #00ffcc; }
        #credits-container { top: 70px; left: 40px; color: #ffaa00; font-size: 20px; }

        /* SPEEDOMETER */
        #speed-container { bottom: 160px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.3); font-size: 20px; text-align: center; }
        #speed-val { font-size: 30px; color: #fff; font-weight: bold; }

        /* TOP CENTER */
        #wave-container { top: 30px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 28px; text-transform: uppercase; }
        #wave-num { color: #ff00ff; font-size: 40px; margin-left: 10px; }

        /* BOTTOM RIGHT (WEAPON) */
        #ammo-container { bottom: 40px; right: 50px; text-align: right; }
        #current-weapon { color: #00ffcc; font-size: 24px; text-transform: uppercase; letter-spacing: 4px; margin-bottom: 5px; }
        #ammo-count { font-size: 80px; font-weight: 900; line-height: 60px; color: #fff; }

        /* HEALTH BAR */
        #health-container { position: absolute; bottom: 40px; left: 50px; }
        .bar-label { font-size: 14px; color: #888; margin-bottom: 5px; font-weight: bold; letter-spacing: 2px; }
        #health-bar-wrapper {
            position: relative; width: 350px; height: 30px;
            background: rgba(20,20,20,0.8); border: 2px solid #555;
            transform: skewX(-20deg); overflow: hidden;
        }
        #health-bar-lag { position: absolute; top:0; left:0; height:100%; width:100%; background: #fff; transition: width 0.5s ease-out 0.2s; }
        #health-bar-fill { position: absolute; top:0; left:0; height:100%; width:100%; background: linear-gradient(90deg, #00ffcc, #0088aa); z-index: 2; transition: width 0.1s linear; }
        #hp-text { position: absolute; right: -70px; bottom: 0; font-size: 40px; font-weight: 900; color: #fff; width: 60px; text-align: right; }

        /* DASH BAR */
        #dash-container { position: absolute; bottom: 100px; left: 50px; width: 200px; }
        #dash-bar-bg { width: 100%; height: 8px; background: rgba(0,0,0,0.5); transform: skewX(-20deg); border: 1px solid #444; }
        #dash-bar-fill { width: 100%; height: 100%; background: #00ffff; box-shadow: 0 0 10px #00ffff; transition: width 0.05s; }

        /* CROSSHAIR & HITMARKER */
        #crosshair-wrapper { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; justify-content: center; align-items: center; }
        #crosshair { width: 4px; height: 4px; background: #00ffcc; border-radius: 50%; box-shadow: 0 0 8px #00ffcc; }
        .hitmarker { position: absolute; width: 20px; height: 20px; border: 2px solid transparent; transform: rotate(45deg); transition: 0.05s; }
        .hit-active { border-color: #ff0000; width: 30px; height: 30px; }

        /* DAMAGE NUMBERS */
        .damage-number { position: absolute; font-weight: 900; font-size: 28px; pointer-events: none; animation: popUp 0.6s forwards; text-shadow: 2px 2px 0 #000; -webkit-text-stroke: 1px black; }
        @keyframes popUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-50px) scale(1.5); } }

        /* SCREENS & MENUS */
        .overlay-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.95); padding: 40px; border: 2px solid #444;
            box-shadow: 0 0 60px rgba(0,0,0,0.9); text-align: center; color: #fff;
            border-radius: 4px; min-width: 500px;
        }
        h1 { margin: 0 0 10px 0; color: #00ffcc; font-size: 48px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 20px rgba(0,255,204,0.4); }
        button {
            background: transparent; border: 2px solid #00ffcc; color: #00ffcc;
            padding: 15px 40px; font-size: 20px; font-weight: 900; cursor: pointer;
            width: 100%; margin-top: 15px; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.1s;
        }
        button:hover { background: #00ffcc; color: #000; box-shadow: 0 0 25px #00ffcc; }
        
        #shop-screen { display: none; width: 800px; max-width: 90%; }
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; max-height: 500px; overflow-y: auto; }
        .shop-item { background: rgba(255,255,255,0.05); padding: 20px; border: 1px solid #333; text-align: left; }

        #wave-message { position: absolute; top: 25%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; width: 100%; }
        #wave-message h1 { font-size: 80px; color: #fff; text-shadow: 0 0 30px #ff00ff; }
        #reload-msg { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); color: #ff3333; font-weight: 900; font-size: 24px; display: none; letter-spacing: 2px; }
        #controls-hint { position: absolute; top: 30px; right: 40px; text-align: right; color: #ffff00; font-size: 14px; opacity: 0.7; line-height: 1.5; font-weight: bold; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair-wrapper"><div id="crosshair"></div><div class="hitmarker" id="hitmarker"></div></div>
        
        <div id="score-container" class="hud-text">SCORE <span id="score">0</span></div>
        <div id="wave-container" class="hud-text">WAVE <span id="wave-num">1</span></div>
        <div id="credits-container" class="hud-text">CREDITS $<span id="credits">0</span></div>

        <div id="speed-container">VELOCITY<br><span id="speed-val">0</span></div>

        <div id="controls-hint">
            [SPACE] JUMP &nbsp; [SHIFT] DASH<br>
            [X] / [R-CLICK] ZOOM<br>
            [U] SHOP &nbsp; [R] RELOAD<br>
            [Q] GRENADE
        </div>

        <div id="health-container">
            <div class="bar-label">ARMOR INTEGRITY</div>
            <div style="display: flex; align-items: center;">
                <div id="health-bar-wrapper">
                    <div id="health-bar-fill"></div>
                    <div id="health-bar-lag"></div>
                </div>
                <div id="hp-text">100</div>
            </div>
        </div>

        <div id="dash-container">
            <div class="bar-label" style="color:#00ffff">BOOST</div>
            <div id="dash-bar-bg"><div id="dash-bar-fill"></div></div>
        </div>

        <div id="ammo-container">
            <div id="current-weapon">BLASTER</div>
            <div id="ammo-count">âˆž</div>
        </div>

        <div id="wave-message"><h1>WAVE COMPLETE</h1></div>
        <div id="reload-msg">RELOADING...</div>
    </div>

    <div id="start-screen" class="overlay-screen">
        <h1>NEON BLAST</h1>
        <h2 style="color: #fff; font-weight: normal; margin-bottom: 30px;">PRECISION EDITION</h2>
        <p style="color: #888;">Tracers are now fully aligned with crosshair.<br>Strafing in air increases speed (Bhop).</p>
        <button id="btnStart">ENGAGE</button>
    </div>

    <div id="shop-screen" class="overlay-screen">
        <h1 style="color: #ffff00;">BLACK MARKET</h1>
        <h2 style="color: #ffaa00;">FUNDS: $<span id="shop-credits">0</span></h2>
        <div class="shop-grid" id="shop-list"></div>
        <button id="btnCloseShop" style="border-color:#fff; color:#fff;">RESUME ACTION</button>
    </div>

    <div id="game-over" class="overlay-screen" style="display:none; border-color: #ff0055;">
        <h1 style="color: #ff0055;">KILLED IN ACTION</h1>
        <p style="font-size: 24px;">WAVES: <span id="final-wave" style="color:#fff">0</span></p>
        <p style="font-size: 24px;">SCORE: <span id="final-score" style="color:#00ffcc">0</span></p>
        <button id="btnRestart" style="border-color: #ff0055; color: #ff0055;">RESTART SIMULATION</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONFIG ---
        const CONFIG = {
            fovNormal: 90, 
            fovZoom: 50,
            gravity: 60,
            jumpForce: 18,
            stopSpeed: 10.0, friction: 6.0, acceleration: 14.0, airAccelerate: 100.0, maxSpeed: 24.0, maxAirSpeed: 4.0
        };

        const GUNS = [
            { id: 0, name: "AUTO-BLASTER", type: 'standard', price: 0, color: 0xffff00, fireRate: 110, spread: 0.04, count: 1, mag: 30, reloadTime: 1000, damage: 16, auto: true },
            { id: 1, name: "SCATTERGUN", type: 'spread', price: 300, color: 0xffaa00, fireRate: 700, spread: 0.15, count: 10, mag: 12, reloadTime: 1800, damage: 12, auto: false },
            { id: 2, name: "PULSE RIFLE", type: 'burst', price: 600, color: 0x00ffff, fireRate: 450, spread: 0.02, count: 1, mag: 40, reloadTime: 1200, damage: 22, auto: false },
            { id: 3, name: "RAIL CANNON", type: 'pierce', price: 1000, color: 0xff00ff, fireRate: 1400, spread: 0, count: 1, mag: 6, reloadTime: 2000, damage: 200, auto: false },
            { id: 4, name: "MINIGUN", type: 'standard', price: 1500, color: 0x00ff00, fireRate: 50, spread: 0.06, count: 1, mag: 150, reloadTime: 3000, damage: 14, auto: true }
        ];

        let scene, camera, renderer, composer, controls;
        let raycaster, groundRaycaster, wallRaycaster;
        let keys={};
        let prevTime = performance.now();
        
        let velocity = new THREE.Vector3();
        let isGrounded = false, canDash = true, dashCooldown = 0;
        let isGameActive = false, isShopOpen = false;
        let score=0, credits=0, waveNum=1, playerHealth=100;
        let grenadeCount=0;
        
        let enemies = [], obstacles = [], activeGrenades = [];
        let enemiesToSpawn=0, waveState='waiting';
        let currentGunIndex=0, ownedGuns=[0], currentAmmo=30;
        let isReloading=false, lastShotTime=0, isMouseDown=false;
        let isZooming=false, adsKeyHeld=false, adsMouseHeld=false;
        let shakeIntensity = 0;

        const ui = {
            score: document.getElementById('score'), credits: document.getElementById('credits'),
            hpFill: document.getElementById('health-bar-fill'), hpLag: document.getElementById('health-bar-lag'),
            hpText: document.getElementById('hp-text'), ammoCount: document.getElementById('ammo-count'),
            curWep: document.getElementById('current-weapon'), reloadMsg: document.getElementById('reload-msg'),
            shopCredits: document.getElementById('shop-credits'), waveNum: document.getElementById('wave-num'),
            waveMsg: document.getElementById('wave-message'), hitmarker: document.getElementById('hitmarker'),
            dashFill: document.getElementById('dash-bar-fill'), speedVal: document.getElementById('speed-val')
        };

        let gunMesh, flashLight, gunContainer;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.015);

            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) starPos.push((Math.random()-0.5)*500, Math.random()*300, (Math.random()-0.5)*500);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x888888, size: 0.7})));

            camera = new THREE.PerspectiveCamera(CONFIG.fovNormal, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass); composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const dl = new THREE.DirectionalLight(0xffffff, 0.5);
            dl.position.set(20, 50, 20); scene.add(dl);
            
            scene.add(new THREE.GridHelper(500, 250, 0x00ffcc, 0x111111));
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({visible:false}));
            floor.rotation.x = -Math.PI/2; floor.userData.isFloor = true;
            scene.add(floor);

            createLevel();

            gunContainer = new THREE.Group();
            camera.add(gunContainer);
            gunMesh = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.18, 0.7), new THREE.MeshStandardMaterial({color:0x222222, emissive:0xffff00, roughness:0.2}));
            gunMesh.position.set(0.3, -0.3, -0.6);
            gunContainer.add(gunMesh);
            
            flashLight = new THREE.PointLight(0xffff00, 0, 15);
            flashLight.position.set(0, 0, -0.7); gunMesh.add(flashLight);
            scene.add(camera);

            controls = new PointerLockControls(camera, document.body);
            raycaster = new THREE.Raycaster();
            groundRaycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0,-1,0), 0, 2.0);
            wallRaycaster = new THREE.Raycaster();

            document.getElementById('btnStart').onclick = () => controls.lock();
            document.getElementById('btnRestart').onclick = resetGame;
            document.getElementById('btnCloseShop').onclick = closeShop;

            controls.addEventListener('lock', () => {
                if (isShopOpen) return;
                document.querySelectorAll('.overlay-screen').forEach(el => el.style.display='none');
                document.getElementById('ui-layer').style.display = 'block';
                isGameActive = true;
                if(waveState === 'waiting') startWave();
            });
            controls.addEventListener('unlock', () => {
                if(!isShopOpen && playerHealth > 0) {
                    document.getElementById('start-screen').style.display='block';
                    document.getElementById('ui-layer').style.display='none';
                    isGameActive = false;
                }
            });

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', e => {
                if(!isGameActive) return;
                if(e.button===0) { isMouseDown=true; if(!GUNS[currentGunIndex].auto) attemptShoot(); }
                if(e.button===2) { adsMouseHeld=true; updateZoom(); }
            });
            document.addEventListener('mouseup', e => {
                if(e.button===0) isMouseDown=false;
                if(e.button===2) { adsMouseHeld=false; updateZoom(); }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            updateHUD();
        }

        function createLevel() {
            const mat = new THREE.MeshStandardMaterial({color:0x111111, roughness:0.1});
            for(let i=0; i<45; i++) {
                const w=3+Math.random()*8, h=5+Math.random()*10, d=3+Math.random()*8;
                const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
                let x, z;
                do { x=(Math.random()-0.5)*180; z=(Math.random()-0.5)*180; } while(Math.abs(x)<20 && Math.abs(z)<20);
                m.position.set(x,h/2,z);
                m.userData = { isWall:true, bbox:new THREE.Box3().setFromObject(m) };
                
                const colors = [0x00ffcc, 0xff00ff, 0xffff00, 0xff3333, 0x0055ff];
                const edges = new THREE.LineSegments(new THREE.EdgesGeometry(m.geometry), new THREE.LineBasicMaterial({color: colors[Math.floor(Math.random()*colors.length)]}));
                m.add(edges);
                scene.add(m); obstacles.push(m);
                m.userData.bbox.setFromObject(m);
            }
        }

        function updateZoom() { isZooming = adsMouseHeld || adsKeyHeld; }

        function applyPhysics(delta) {
            groundRaycaster.ray.origin.copy(camera.position);
            const hits = groundRaycaster.intersectObjects(scene.children);
            isGrounded = hits.some(h => h.object.userData.isFloor || h.object.type==='GridHelper');

            if (keys['Space'] && isGrounded) { velocity.y = CONFIG.jumpForce; isGrounded = false; }

            let dir = new THREE.Vector3();
            if(keys['KeyW']) dir.z += 1; if(keys['KeyS']) dir.z -= 1;
            if(keys['KeyA']) dir.x -= 1; if(keys['KeyD']) dir.x += 1;
            
            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
            const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
            const wishDir = new THREE.Vector3().addScaledVector(fwd, dir.z).addScaledVector(right, dir.x).normalize();
            
            if (isGrounded) {
                applyFriction(delta);
                accelerate(wishDir, CONFIG.maxSpeed, CONFIG.acceleration, delta);
                if(keys['ShiftLeft'] && canDash && wishDir.lengthSq()>0) {
                    velocity.addScaledVector(wishDir, 40); velocity.y = 5;
                    canDash=false; dashCooldown=1.5; isGrounded=false;
                }
            } else {
                accelerate(wishDir, CONFIG.maxAirSpeed, CONFIG.airAccelerate, delta);
            }

            if (!isGrounded) velocity.y -= CONFIG.gravity * delta;
            else if (velocity.y < 0) velocity.y = 0;

            controls.getObject().position.addScaledVector(velocity, delta);

            const pBox = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(1,2,1));
            for(let w of obstacles) {
                if(pBox.intersectsBox(w.userData.bbox)) {
                    const wb = w.userData.bbox;
                    const dx = Math.min(Math.abs(wb.max.x-pBox.min.x), Math.abs(pBox.max.x-wb.min.x));
                    const dz = Math.min(Math.abs(wb.max.z-pBox.min.z), Math.abs(pBox.max.z-wb.min.z));
                    if(dx<dz) { camera.position.x += dx*(camera.position.x>w.position.x?1:-1); velocity.x=0; }
                    else { camera.position.z += dz*(camera.position.z>w.position.z?1:-1); velocity.z=0; }
                }
            }
            if(camera.position.y < 2) { camera.position.y=2; isGrounded=true; }

            if(dashCooldown > 0) {
                dashCooldown -= delta;
                ui.dashFill.style.width = ((1.5-dashCooldown)/1.5*100)+'%';
                if(dashCooldown<=0) canDash=true;
            }
            ui.speedVal.innerText = Math.round(new THREE.Vector2(velocity.x, velocity.z).length());
        }

        function applyFriction(delta) {
            let speed = new THREE.Vector2(velocity.x, velocity.z).length();
            if (speed < 0.1) return;
            let control = (speed < CONFIG.stopSpeed) ? CONFIG.stopSpeed : speed;
            let drop = control * CONFIG.friction * delta;
            let newSpeed = speed - drop;
            if (newSpeed < 0) newSpeed = 0;
            if (speed > 0) {
                newSpeed /= speed;
                velocity.x *= newSpeed;
                velocity.z *= newSpeed;
            }
        }

        function accelerate(wishDir, wishSpeed, accel, delta) {
            let currentSpeed = velocity.dot(wishDir);
            let addSpeed = wishSpeed - currentSpeed;
            if (addSpeed <= 0) return;
            let accelSpeed = accel * delta * wishSpeed;
            if (accelSpeed > addSpeed) accelSpeed = addSpeed;
            velocity.x += accelSpeed * wishDir.x;
            velocity.z += accelSpeed * wishDir.z;
        }

        function attemptShoot() {
            if(isReloading || isShopOpen) return;
            const now = performance.now();
            const gun = GUNS[currentGunIndex];
            if(currentAmmo <= 0) { reload(); return; }

            if(now - lastShotTime >= gun.fireRate) {
                if(gun.type==='burst') {
                    const b=()=>{if(currentAmmo>0) fireShot(gun);};
                    b(); setTimeout(b,80); setTimeout(b,160); lastShotTime=now+160; currentAmmo--;
                } else {
                    fireShot(gun); lastShotTime=now; currentAmmo--;
                }
                updateHUD();
                shakeIntensity = 0.3; gunMesh.position.z += 0.2;
            }
        }

        // --- NEW FIRING LOGIC ---
        function fireShot(gun) {
            flashLight.intensity=3; setTimeout(()=>flashLight.intensity=0, 50);
            
            // Get Gun Barrel World Position
            const barrelPos = new THREE.Vector3(0.3, -0.3, -0.6);
            barrelPos.applyMatrix4(gunContainer.matrixWorld);

            for(let i=0; i<gun.count; i++) {
                let s = isZooming ? gun.spread*0.3 : gun.spread;
                const x = (Math.random()-0.5)*s;
                // Tiny Y offset (0.002) to fix "under crosshair" feeling
                const y = (Math.random()-0.5)*s + 0.002; 
                
                // 1. Calculate Hit
                raycaster.setFromCamera(new THREE.Vector2(x,y), camera);
                const hits = raycaster.intersectObjects(scene.children);
                
                let targetPoint = null;
                let hitObject = null;

                // Find valid hit
                for(let hit of hits) {
                    if(hit.object.userData.isFloor) continue;
                    if(hit.object.userData.isWall || hit.object.userData.isEnemy) {
                        targetPoint = hit.point;
                        hitObject = hit.object;
                        break;
                    }
                }

                // If no hit, create a fake point far away
                if(!targetPoint) {
                    targetPoint = new THREE.Vector3(x, y, -0.5).unproject(camera).normalize().multiplyScalar(100).add(camera.position);
                }

                // 2. Draw Tracer (World Space: Barrel -> Target)
                const lineGeo = new THREE.BufferGeometry().setFromPoints([barrelPos, targetPoint]);
                const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:gun.color}));
                scene.add(line); // Add to scene, not camera!
                setTimeout(()=>{ scene.remove(line); line.geometry.dispose(); line.material.dispose(); }, 40);

                // 3. Process Damage
                if(hitObject) {
                    if(hitObject.userData.isWall) {
                        spawnSpark(targetPoint, 5, 0x00ffcc);
                    } else if(hitObject.userData.isEnemy) {
                        hitObject.userData.hp -= gun.damage;
                        if(hitObject.userData.hpBar) hitObject.userData.hpBar.scale.x = Math.max(0, hitObject.userData.hp / hitObject.userData.maxHp);
                        spawnDmgNum(targetPoint, gun.damage);
                        spawnSpark(targetPoint, 8, hitObject.userData.color);
                        const hm = ui.hitmarker; hm.classList.add('hit-active'); setTimeout(()=>hm.classList.remove('hit-active'), 80);
                        if(hitObject.userData.hp <= 0) killEnemy(hitObject);
                    }
                }
            }
        }

        function reload() {
            if(isReloading || currentAmmo===GUNS[currentGunIndex].mag) return;
            isReloading=true; ui.reloadMsg.style.display='block'; ui.ammoCount.innerText="REL";
            setTimeout(()=>{
                if(currentGunIndex === GUNS[currentGunIndex].id) {
                    currentAmmo=GUNS[currentGunIndex].mag; isReloading=false; ui.reloadMsg.style.display='none'; updateHUD();
                }
            }, GUNS[currentGunIndex].reloadTime);
        }

        function spawnDmgNum(pos, val) {
            const d = document.createElement('div');
            d.className='damage-number'; d.innerText=val; d.style.color='#fff';
            document.body.appendChild(d);
            const v = pos.clone().project(camera);
            d.style.left = (v.x*.5+.5)*window.innerWidth+'px'; d.style.top = (-(v.y*.5)+.5)*window.innerHeight+'px';
            setTimeout(()=>d.remove(), 600);
        }
        function spawnSpark(pos, n, col) {
            const geo = new THREE.BufferGeometry();
            const p = []; for(let i=0; i<n; i++) p.push(pos.x, pos.y, pos.z);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(p,3));
            const pts = new THREE.Points(geo, new THREE.PointsMaterial({color:col, size:0.2}));
            scene.add(pts);
            const dirs = Array(n).fill().map(()=>new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5).normalize());
            let life=1;
            function anim(){
                life-=0.1; const att=pts.geometry.attributes.position;
                for(let i=0; i<n; i++) att.setXYZ(i, att.getX(i)+dirs[i].x*0.4, att.getY(i)+dirs[i].y*0.4, att.getZ(i)+dirs[i].z*0.4);
                att.needsUpdate=true;
                if(life>0) requestAnimationFrame(anim); else { scene.remove(pts); geo.dispose(); }
            } anim();
        }

        function startWave() {
            waveState = 'spawning';
            enemiesToSpawn = 8 + Math.floor(waveNum * 4);
            ui.waveNum.innerText = waveNum; ui.waveMsg.style.display = 'none';
            const intv = setInterval(() => {
                if(!isGameActive) { clearInterval(intv); return; }
                if(enemiesToSpawn > 0) { spawnEnemy(); enemiesToSpawn--; } 
                else clearInterval(intv);
            }, 600 - Math.min(400, waveNum*10));
        }

        function spawnEnemy() {
            const ang = Math.random()*Math.PI*2;
            const dist = 30 + Math.random()*30;
            const x = camera.position.x + Math.cos(ang)*dist;
            const z = camera.position.z + Math.sin(ang)*dist;
            
            const r = Math.random();
            let d = { name:'chaser', hp:50, speed:8, color:0xff0055, score:10, type:'ground' };
            if (waveNum > 1 && r > 0.85) d = { name:'drone', hp:40, speed:10, color:0x00ffff, score:25, type:'fly' };
            else if (r > 0.70) d = { name:'tank', hp:250, speed:4, color:0xff8800, score:40, type:'ground' };
            else if (r > 0.55) d = { name:'exploder', hp:30, speed:14, color:0xff0000, score:15, type:'ground' };
            d.hp += waveNum*10;

            let geo;
            let yPos = 1;
            if (d.name==='drone') { geo = new THREE.OctahedronGeometry(0.8); yPos = 5 + Math.random()*3; }
            else if (d.name==='tank') { geo = new THREE.IcosahedronGeometry(1.2,0); yPos = 1.2; }
            else if (d.name==='exploder') { geo = new THREE.SphereGeometry(0.6, 8, 8); }
            else { geo = new THREE.TetrahedronGeometry(0.8); }

            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0x111111, emissive:d.color, emissiveIntensity:2}));
            mesh.position.set(x, yPos, z);
            mesh.userData = { isEnemy:true, ...d, maxHp:d.hp };

            const bg = new THREE.Mesh(new THREE.PlaneGeometry(1,0.1), new THREE.MeshBasicMaterial({color:0x550000}));
            const fg = new THREE.Mesh(new THREE.PlaneGeometry(1,0.1), new THREE.MeshBasicMaterial({color:0x00ff00}));
            fg.position.z=0.01; fg.geometry.translate(0.5,0,0); fg.position.x=-0.5;
            const grp = new THREE.Group(); grp.add(bg,fg); grp.position.y = 1.5;
            mesh.add(grp); mesh.userData.hpBar=fg; mesh.userData.barGroup=grp;

            scene.add(mesh); enemies.push(mesh);
        }

        function killEnemy(e) {
            spawnSpark(e.position, 20, e.userData.color);
            score += e.userData.score; credits += e.userData.score;
            scene.remove(e); enemies = enemies.filter(x => x!==e);
            updateHUD();
            if(enemies.length===0 && enemiesToSpawn===0 && waveState==='spawning') {
                waveState='cleared'; ui.waveMsg.style.display='block';
                setTimeout(()=>{ waveNum++; startWave(); }, 2500);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime)/1000, 0.1);

            if(isGameActive) {
                applyPhysics(delta);

                const tx = (keys['KeyA']?0.08:0) - (keys['KeyD']?0.08:0);
                const ty = -0.3 + Math.sin(time*0.015)*0.005;
                gunMesh.position.x = THREE.MathUtils.lerp(gunMesh.position.x, 0.3 + tx, 0.1);
                gunMesh.position.y = THREE.MathUtils.lerp(gunMesh.position.y, ty, 0.1);
                gunMesh.position.z = THREE.MathUtils.lerp(gunMesh.position.z, -0.6, 0.1);

                if (shakeIntensity > 0) {
                    const rx = (Math.random()-0.5) * shakeIntensity;
                    const ry = (Math.random()-0.5) * shakeIntensity;
                    camera.position.add(new THREE.Vector3(rx, ry, 0));
                    shakeIntensity -= delta * 2;
                    if(shakeIntensity < 0) shakeIntensity = 0;
                }

                camera.fov = THREE.MathUtils.lerp(camera.fov, isZooming ? CONFIG.fovZoom : CONFIG.fovNormal, 0.15);
                camera.updateProjectionMatrix();

                if(isMouseDown && GUNS[currentGunIndex].auto) attemptShoot();

                enemies.forEach(e => {
                    e.userData.barGroup.lookAt(camera.position);
                    const dist = e.position.distanceTo(camera.position);
                    const dir = new THREE.Vector3().subVectors(camera.position, e.position).normalize();
                    
                    if (e.userData.type === 'fly') {
                        e.position.addScaledVector(dir, e.userData.speed * delta);
                        e.position.y += Math.sin(time*0.005) * 0.02;
                    } else {
                        dir.y = 0; dir.normalize();
                        wallRaycaster.set(e.position, dir);
                        const wh = wallRaycaster.intersectObjects(obstacles);
                        if(!wh.length || wh[0].distance > 2) {
                            e.lookAt(camera.position.x, e.position.y, camera.position.z);
                            e.translateZ(e.userData.speed * delta);
                        }
                    }

                    if(dist < 1.5) {
                        playerHealth -= 10; updateHUD();
                        if(e.userData.name === 'exploder') { playerHealth -= 30; killEnemy(e); } 
                        else {
                            const a = Math.atan2(e.position.x-camera.position.x, e.position.z-camera.position.z);
                            e.position.x += Math.sin(a)*5; e.position.z += Math.cos(a)*5;
                        }
                        const f=document.createElement('div');
                        f.style.cssText=`position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.4);pointer-events:none;`;
                        document.body.appendChild(f); setTimeout(()=>f.remove(), 100);

                        if(playerHealth<=0) {
                            isGameActive=false; controls.unlock();
                            document.getElementById('ui-layer').style.display='none';
                            document.getElementById('game-over').style.display='block';
                            document.getElementById('final-score').innerText=score;
                            document.getElementById('final-wave').innerText=waveNum;
                        }
                    }
                });

                activeGrenades.forEach((g,i) => {
                    g.vel.y -= CONFIG.gravity*delta; g.mesh.position.addScaledVector(g.vel, delta);
                    if(g.mesh.position.y<0.5) { g.mesh.position.y=0.5; g.vel.y*=-0.5; g.vel.multiplyScalar(0.7); }
                    g.life -= delta;
                    if(g.life<=0) {
                        spawnSpark(g.mesh.position, 30, 0xff0000);
                        enemies.forEach(e=>{ if(e.position.distanceTo(g.mesh.position)<15) { e.userData.hp-=100; if(e.userData.hp<=0)killEnemy(e); }});
                        scene.remove(g.mesh); activeGrenades.splice(i,1);
                    }
                });

            } else { camera.rotation.y += 0.0005; }

            prevTime = time;
            composer.render();
        }

        function updateHUD() {
            ui.score.innerText = score; ui.credits.innerText = credits; ui.hpText.innerText = Math.max(0, playerHealth);
            ui.hpFill.style.width = Math.max(0, playerHealth)+'%'; ui.hpLag.style.width = Math.max(0, playerHealth)+'%';
            if(!isReloading) ui.ammoCount.innerText = currentAmmo;
            ui.curWep.innerText = GUNS[currentGunIndex].name;
            ui.curWep.style.color = '#'+GUNS[currentGunIndex].color.toString(16);
            if(isShopOpen) ui.shopCredits.innerText=credits;
            if(playerHealth<40) ui.hpFill.style.background = '#ff0000';
            else ui.hpFill.style.background = 'linear-gradient(90deg, #00ffcc, #0088aa)';
        }

        function resetGame() {
            enemies.forEach(e=>scene.remove(e)); enemies=[]; obstacles.forEach(o=>scene.remove(o)); obstacles=[];
            createLevel(); score=0; credits=0; playerHealth=100; waveNum=1; ownedGuns=[0]; currentGunIndex=0; currentAmmo=GUNS[0].mag;
            camera.position.set(0,2,0); velocity.set(0,0,0);
            gunMesh.material.emissive.setHex(GUNS[0].color);
            controls.lock(); startWave();
        }

        function toggleShop(){ if(isShopOpen)closeShop(); else openShop(); }
        function openShop(){ 
            isShopOpen=true; isGameActive=false; controls.unlock(); 
            document.getElementById('shop-screen').style.display='block'; document.getElementById('ui-layer').style.display='none';
            const l=document.getElementById('shop-list'); l.innerHTML='';
            GUNS.forEach((g,i)=>{
                if(i===0)return;
                const o=ownedGuns.includes(i);
                const b=o?`<button disabled>OWNED</button>`:(credits>=g.price?`<button id="b${i}">BUY $${g.price}</button>`:`<button disabled>$${g.price}</button>`);
                l.innerHTML+=`<div class="shop-item"><h3 style="color:#${g.color.toString(16)}">${g.name}</h3><p>${g.type.toUpperCase()}</p>${b}</div>`;
            });
            l.innerHTML+=`<div class="shop-item"><h3>MEDKIT (+50HP)</h3><button id="bRep" ${credits<150?'disabled':''}>BUY $150</button></div>`;
            l.innerHTML+=`<div class="shop-item"><h3>GRENADE</h3><button id="bGre" ${credits<200?'disabled':''}>BUY $200</button></div>`;
            setTimeout(()=>{
                GUNS.forEach((g,i)=>{const el=document.getElementById(`b${i}`); if(el)el.onclick=()=>{credits-=g.price;ownedGuns.push(i);currentGunIndex=i;currentAmmo=g.mag;updateHUD();openShop();}});
                document.getElementById('bRep').onclick=()=>{if(credits>=150){credits-=150;playerHealth=Math.min(100,playerHealth+50);updateHUD();openShop();}};
                document.getElementById('bGre').onclick=()=>{if(credits>=200){credits-=200;grenadeCount++;updateHUD();openShop();}};
            },100);
        }
        function closeShop(){ isShopOpen=false; document.getElementById('shop-screen').style.display='none'; controls.lock(); }

        function onKeyDown(e) {
            keys[e.code]=true;
            if(e.code==='KeyX') { adsKeyHeld=true; updateZoom(); }
            if(e.code==='KeyU') toggleShop();
            if(e.code==='KeyR') reload();
            if(e.code==='KeyQ' && grenadeCount>0) {
                grenadeCount--;
                const m=new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), new THREE.MeshStandardMaterial({color:0xff0000,emissive:0xff0000}));
                m.position.copy(camera.position); 
                const d=new THREE.Vector3(); camera.getWorldDirection(d);
                activeGrenades.push({mesh:m, vel:d.multiplyScalar(30).add(new THREE.Vector3(0,10,0)), life:2});
                scene.add(m);
            }
            if(['Digit1','Digit2','Digit3','Digit4','Digit5'].includes(e.code)) {
                const i=parseInt(e.code.slice(-1))-1;
                if(ownedGuns.includes(i)) { currentGunIndex=i; currentAmmo=GUNS[i].mag; gunMesh.material.emissive.setHex(GUNS[i].color); updateHUD(); }
            }
        }
        function onKeyUp(e) {
            keys[e.code]=false;
            if(e.code==='KeyX') { adsKeyHeld=false; updateZoom(); }
        }
    </script>
</body>
</html>