<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Slope - Difficulty Modes</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        /* Back button */
        #back-btn {
            position: absolute;
            top: 20px; right: 20px;
            color: #fff; text-decoration: none;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px; border: 1px solid #fff;
            z-index: 100; font-weight: bold;
        }
        #back-btn:hover { background: #fff; color: #000; box-shadow: 0 0 15px #fff; }

        #ui-container {
            position: absolute; top: 20px; left: 20px;
            color: #00ffcc; font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px #00ffcc;
            pointer-events: none; z-index: 10;
            display: none; /* Hidden until game starts */
        }

        /* Shared style for Menu and Game Over screens */
        .overlay-screen {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px; border: 2px solid #00ffcc;
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(10px);
            z-index: 20; border-radius: 10px;
            min-width: 300px;
        }

        #game-over { display: none; border-color: #ff0055; box-shadow: 0 0 50px #ff0055; }
        
        h1 { margin: 0 0 20px 0; font-size: 40px; color: #fff; text-shadow: 0 0 20px currentColor; }
        h2 { font-size: 20px; color: #ccc; margin-bottom: 30px; }

        .btn-group { display: flex; flex-direction: column; gap: 15px; }

        button {
            background: transparent; border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 15px 30px; font-size: 20px;
            cursor: pointer; font-family: inherit; font-weight: bold;
            text-transform: uppercase;
            transition: 0.2s;
        }
        button:hover { background: #00ffcc; color: #000; box-shadow: 0 0 30px #00ffcc; transform: scale(1.05); }

        /* specific colors for difficulty */
        .btn-easy { border-color: #00ff00; color: #00ff00; }
        .btn-easy:hover { background: #00ff00; box-shadow: 0 0 30px #00ff00; }

        .btn-normal { border-color: #00ffff; color: #00ffff; }
        .btn-normal:hover { background: #00ffff; box-shadow: 0 0 30px #00ffff; }

        .btn-hard { border-color: #ff0055; color: #ff0055; }
        .btn-hard:hover { background: #ff0055; box-shadow: 0 0 30px #ff0055; }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <a href="index.html" id="back-btn">‚Üê BACK TO HUB</a>

    <div id="ui-container">
        SCORE: <span id="score">0</span>
    </div>

    <div id="start-screen" class="overlay-screen">
        <h1 style="color: #00ffcc;">NEON SLOPE</h1>
        <h2>SELECT DIFFICULTY</h2>
        <div class="btn-group">
            <button class="btn-easy" id="btnEasy">EASY MODE</button>
            <button class="btn-normal" id="btnNormal">NORMAL MODE</button>
            <button class="btn-hard" id="btnHard">HARD MODE</button>
        </div>
    </div>

    <div id="game-over" class="overlay-screen">
        <h1>SYSTEM CRASH</h1>
        <p style="font-size: 18px; color: #ccc;">FINAL SCORE: <span id="final-score" style="color: #00ffcc;">0</span></p>
        <button id="restartBtn">MAIN MENU</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        const CONFIG = {
            colorBg: 0x020202,
            colorPlatform: 0x00ffcc,
            colorObstacle: 0xff0055,
            colorPlayer: 0xffffff,
            bloomStrength: 2.0, 
            bloomRadius: 0.5,   
            bloomThreshold: 0.1
        };

        // --- GLOBALS ---
        let scene, camera, renderer, composer, player;
        let platforms = [], obstacles = [], debris = [];
        let isGameOver = false, isGameStarted = false;
        let score = 0;
        let speed = 0.6, speedIncrement = 0.0005, maxSpeed = 0.8;
        
        // Physics
        let lastZ = 0, lastX = 0;
        let playerVelocityX = 0, playerVelocityY = 0;
        const gravity = 0.025, moveSpeed = 0.035, friction = 0.90;
        
        // Inputs
        let keys = { ArrowLeft: false, ArrowRight: false, a: false, d: false };

        // --- DIFFICULTY SETTINGS ---
        let currentDifficulty = {
            obstacleChance: 0.3, // Lower number = fewer obstacles (logic inverted in code)
            scoreMultiplier: 1
        };

        init();
        animate();

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colorBg);
            scene.fog = new THREE.FogExp2(CONFIG.colorBg, 0.02); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 7);

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            // 3. Post-Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = CONFIG.bloomThreshold;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 4. Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.1));
            const playerLight = new THREE.PointLight(CONFIG.colorPlatform, 1, 20);
            playerLight.position.set(0, 5, 0);
            scene.add(playerLight);

            // 5. Player
            const pGeo = new THREE.OctahedronGeometry(0.5); 
            const pMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0x00ffff, 
                emissiveIntensity: 1.0,
                roughness: 0.1, 
                metalness: 0.9 
            });
            player = new THREE.Mesh(pGeo, pMat);
            player.position.y = 1;
            scene.add(player);
            player.add(new THREE.PointLight(0x00ffff, 2, 10));

            // Generate initial world (visual only until start)
            createInitialPlatform();

            // 6. Events
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
            
            // Buttons
            document.getElementById('restartBtn').addEventListener('click', showMainMenu);
            
            document.getElementById('btnEasy').addEventListener('click', () => startGame('easy'));
            document.getElementById('btnNormal').addEventListener('click', () => startGame('normal'));
            document.getElementById('btnHard').addEventListener('click', () => startGame('hard'));
        }

        function startGame(mode) {
            // SET DIFFICULTY
            if (mode === 'easy') {
                currentDifficulty.obstacleChance = 0.8; // Only spawn if random > 0.8 (20% chance)
                currentDifficulty.scoreMultiplier = 1;
            } else if (mode === 'normal') {
                currentDifficulty.obstacleChance = 0.3; // Spawn if random > 0.3 (70% chance)
                currentDifficulty.scoreMultiplier = 1;
            } else if (mode === 'hard') {
                currentDifficulty.obstacleChance = 0.1; // Spawn if random > 0.1 (90% chance)
                currentDifficulty.scoreMultiplier = 2; // Double points
            }

            // Reset Game Logic
            resetGameEntities();
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('ui-container').style.display = 'block';
            
            isGameStarted = true;
            isGameOver = false;
        }

        function showMainMenu() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('start-screen').style.display = 'block';
            document.getElementById('ui-container').style.display = 'none';
            isGameStarted = false;
            resetGameEntities();
        }

        function createInitialPlatform() {
            lastZ = 0; lastX = 0;
            createPlatform(0, 0, 0, 10, 20);
            lastZ = -10;
            for(let i = 0; i < 15; i++) generateProceduralChunk();
        }

        function generateProceduralChunk() {
            const width = Math.random() * 4 + 6;
            const length = 10;
            const maxShift = width / 2; 
            const shift = (Math.random() - 0.5) * maxShift * 2.5; 
            const newX = lastX + shift;
            const newZ = lastZ - (length / 2);

            createPlatform(newX, 0, newZ, width, length);

            // --- DIFFICULTY LOGIC APPLIED HERE ---
            // If random number is greater than chance setting, spawn obstacle
            if (Math.random() > currentDifficulty.obstacleChance) {
                const obsX = newX + (Math.random() - 0.5) * (width - 2); 
                createObstacle(obsX, 1, newZ);
            }

            lastX = newX;
            lastZ = newZ - (length / 2);
        }

        function createPlatform(x, y, z, width, depth) {
            const geometry = new THREE.BoxGeometry(width, 1, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                roughness: 0.1,
                metalness: 0.8
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y - 0.5, z);
            
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ color: CONFIG.colorPlatform });
            const lines = new THREE.LineSegments(edges, lineMat);
            lines.material.color.setHex(CONFIG.colorPlatform); 
            
            platform.add(lines);
            scene.add(platform);
            platforms.push(platform);
        }

        function createObstacle(x, y, z) {
            const geometry = new THREE.TetrahedronGeometry(0.6);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                emissive: CONFIG.colorObstacle,
                emissiveIntensity: 2.0, 
                roughness: 0.1
            });
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(x, y, z);
            obstacle.rotation.x = Math.random();
            obstacle.rotation.y = Math.random();

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function createExplosion(position) {
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            
            for (let i = 0; i < 30; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                mesh.userData.velocity = new THREE.Vector3(
                    (Math.random()-0.5) * 1.5,
                    (Math.random()-0.5) * 1.5,
                    (Math.random()-0.5) * 1.5
                );
                scene.add(mesh);
                debris.push(mesh);
            }
        }

        function resetGameEntities() {
            platforms.forEach(p => { 
                scene.remove(p);
                p.geometry.dispose(); 
            });
            obstacles.forEach(o => { 
                scene.remove(o); 
                o.geometry.dispose();
            });
            debris.forEach(d => scene.remove(d));
            
            platforms = []; obstacles = []; debris = [];
            
            player.position.set(0, 1, 0);
            playerVelocityX = 0; playerVelocityY = 0;
            score = 0; 
            speed = 0.6; 
            player.visible = true;
            document.getElementById('score').innerText = '0';
            
            createInitialPlatform();
        }

        function handleInput() {
            if (keys.ArrowLeft || keys.a) playerVelocityX -= moveSpeed;
            if (keys.ArrowRight || keys.d) playerVelocityX += moveSpeed;
        }

        function updatePhysics() {
            player.position.z -= speed;
            player.position.x += playerVelocityX;
            playerVelocityX *= friction;

            const raycaster = new THREE.Raycaster(player.position, new THREE.Vector3(0, -1, 0), 0, 1.5);
            const hits = raycaster.intersectObjects(platforms);

            if (hits.length > 0) {
                playerVelocityY = 0; 
                player.position.y = 0.5;
            } else {
                playerVelocityY -= gravity; 
                player.position.y += playerVelocityY;
            }

            player.rotation.x -= speed * 0.3;
            player.rotation.z = -playerVelocityX * 2;

            if (player.position.y < -5) triggerGameOver();
            
            for (let obs of obstacles) { 
                if (player.position.distanceTo(obs.position) < 1.0) triggerGameOver(); 
            }
        }

        function updateWorld() {
            if(speed < maxSpeed) speed += speedIncrement;
            
            // Score Calculation with Multiplier
            const rawScore = Math.floor(Math.abs(player.position.z) / 10);
            score = rawScore * currentDifficulty.scoreMultiplier;
            document.getElementById('score').innerText = score;

            if (player.position.z < lastZ + 120) generateProceduralChunk();

            if (platforms.length > 45) { 
                const old = platforms.shift(); 
                scene.remove(old); 
                old.geometry.dispose();
                if(old.material) old.material.dispose();
            }
            if (obstacles.length > 20 && obstacles[0].position.z > player.position.z + 20) { 
                const old = obstacles.shift(); 
                scene.remove(old); 
            }
        }

        function triggerGameOver() {
            if(isGameOver) return;
            isGameOver = true;
            createExplosion(player.position);
            player.visible = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('ui-container').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isGameStarted && !isGameOver) {
                handleInput();
                updatePhysics();
                updateWorld();

                // Camera Logic
                camera.position.x = player.position.x; 
                camera.position.y = player.position.y + 2.5; 
                camera.position.z = player.position.z + 7;   
                
                camera.lookAt(player.position.x, player.position.y, player.position.z - 10);
                
                // Obstacle Animation
                obstacles.forEach(o => {
                    o.rotation.x += 0.02;
                    o.rotation.y += 0.02;
                });

            } else if (isGameOver) {
                // Debris animation
                debris.forEach(p => { 
                    p.position.add(p.userData.velocity); 
                    p.rotation.x += 0.1; 
                    p.scale.multiplyScalar(0.95); 
                });
            } else {
                // Idle Camera spin for start menu
                camera.position.x = Math.sin(Date.now() * 0.0005) * 2;
                camera.lookAt(0, 0, -5);
            }

            composer.render();
        }

        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
